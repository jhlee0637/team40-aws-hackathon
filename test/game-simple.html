<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWS 노들섬 퀴즈 배틀 RPG</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: monospace;
        }
        
        #gameCanvas {
            border: 2px solid #FF9900;
            background: #87CEEB;
            image-rendering: pixelated;
        }
        
        .game-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div class="game-info">
        <h3>🎮 AWS 노들섬 퀴즈 배틀 RPG</h3>
        <p>WASD: 이동 | Space: 상호작용 | 1-4: 퀴즈 답변</p>
    </div>
    
    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.ctx.imageSmoothingEnabled = false;
                
                this.gameState = 'overworld';
                this.time = 0;
                this.deltaTime = 0;
                this.lastTime = performance.now();
                
                this.camera = { x: 0, y: 0, targetX: 0, targetY: 0, smoothing: 0.08 };
                this.keys = {};
                
                this.tileSize = 16;
                this.mapWidth = 80;
                this.mapHeight = 60;
                this.map = [];
                this.collisionMap = [];
                
                this.player = {
                    x: 400, y: 600, width: 16, height: 16, speed: 2,
                    direction: 'down', moving: false, animFrame: 0,
                    hp: 100, maxHp: 100, level: 1, exp: 0, expToNext: 100,
                    awsCredits: 1000, name: '클라우드 엔지니어'
                };
                
                this.battleSystem = {
                    active: false,
                    monster: null,
                    currentQuestion: null,
                    damageNumbers: []
                };
                
                this.gameData = {
                    quiz: {
                        cp: [
                            {
                                question: "AWS 클라우드의 6가지 장점 중 하나가 아닌 것은?",
                                options: ["민첩성 향상", "비용 절감", "데이터 소유권 보장", "글로벌 확장"],
                                correct: 2,
                                explanation: "AWS는 데이터 소유권을 보장하지 않습니다. 고객이 데이터를 소유합니다.",
                                difficulty: 1
                            },
                            {
                                question: "S3 버킷 이름의 특징은?",
                                options: ["리전별로 고유", "계정별로 고유", "전 세계적으로 고유", "AZ별로 고유"],
                                correct: 2,
                                explanation: "S3 버킷 이름은 전 세계적으로 고유해야 합니다.",
                                difficulty: 1
                            }
                        ],
                        saa: [
                            {
                                question: "Multi-AZ RDS 배포의 주요 목적은?",
                                options: ["성능 향상", "고가용성", "비용 절감", "보안 강화"],
                                correct: 1,
                                explanation: "Multi-AZ는 고가용성과 자동 장애 조치를 제공합니다.",
                                difficulty: 2
                            }
                        ]
                    }
                };
                
                this.monsters = [
                    {
                        x: 10, y: 20, name: "S3 버킷몬", type: "s3",
                        hp: 60, maxHp: 60, level: 3, cert: "cp",
                        defeated: false, moveTimer: 0
                    },
                    {
                        x: 30, y: 25, name: "VPC 네트워크", type: "vpc",
                        hp: 100, maxHp: 100, level: 6, cert: "saa",
                        defeated: false, moveTimer: 0
                    }
                ];
                
                this.gymLeaders = [
                    {
                        x: 16, y: 30, name: "박클라우드", title: "CP 관장",
                        cert: "cp", defeated: false,
                        dialogue: ["안녕하세요! CP 관장입니다.", "AWS 기초를 배워보시죠!"],
                        certDetails: {
                            fullName: "AWS Certified Cloud Practitioner",
                            code: "CLF-C01",
                            duration: "90분",
                            questions: "65문항",
                            passingScore: "700/1000점",
                            cost: "$100",
                            validity: "3년",
                            domains: ["클라우드 개념 (26%)", "보안 (25%)"]
                        }
                    }
                ];
                
                this.interactionCooldown = 0;
                
                this.init();
            }
            
            init() {
                console.log('게임 초기화 시작...');
                this.generateMap();
                this.setupEventHandlers();
                console.log('게임 초기화 완료!');
                this.gameLoop();
            }
            
            generateMap() {
                this.collisionMap = [];
                this.map = [];
                
                for (let y = 0; y < this.mapHeight; y++) {
                    const mapRow = [];
                    const collisionRow = [];
                    
                    for (let x = 0; x < this.mapWidth; x++) {
                        if (x < 25) mapRow.push(1);
                        else if (x < 50) mapRow.push(15);
                        else mapRow.push(16);
                        collisionRow.push(0);
                    }
                    
                    this.map.push(mapRow);
                    this.collisionMap.push(collisionRow);
                }
                
                // 강 추가
                for (let x = 0; x < this.mapWidth; x++) {
                    const progress = x / this.mapWidth;
                    const riverTop = 8 + Math.sin(progress * Math.PI * 1.5) * 3;
                    for (let offset = -3; offset <= 3; offset++) {
                        const riverY = Math.floor(riverTop + offset);
                        if (riverY >= 0 && riverY < this.mapHeight) {
                            this.map[riverY][x] = 2;
                            this.collisionMap[riverY][x] = 1;
                        }
                    }
                }
                
                // 나무 추가
                for (let y = 15; y < 45; y++) {
                    for (let x = 5; x < 75; x++) {
                        if (Math.random() < 0.1) {
                            this.map[y][x] = 3;
                            this.collisionMap[y][x] = 1;
                        }
                    }
                }
                
                // 건물 추가
                const buildings = [
                    {x: 30, y: 25, w: 6, h: 4, type: 8},
                    {x: 16, y: 30, w: 3, h: 2, type: 11}
                ];
                
                buildings.forEach(building => {
                    for (let y = building.y; y < building.y + building.h; y++) {
                        for (let x = building.x; x < building.x + building.w; x++) {
                            if (x < this.mapWidth && y < this.mapHeight) {
                                this.map[y][x] = building.type;
                                this.collisionMap[y][x] = 1;
                            }
                        }
                    }
                });
            }
            
            setupEventHandlers() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    if (this.gameState === 'battle' && e.key >= '1' && e.key <= '4') {
                        this.handleBattleAnswer(parseInt(e.key) - 1);
                    }
                    
                    e.preventDefault();
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
            }
            
            update() {
                const currentTime = performance.now();
                this.deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.time = currentTime;
                
                if (this.gameState === 'overworld') {
                    this.updatePlayer();
                    this.updateMonsters();
                    this.updateCamera();
                    this.checkInteractions();
                } else if (this.gameState === 'battle') {
                    this.updateBattle();
                }
            }
            
            updatePlayer() {
                const oldX = this.player.x;
                const oldY = this.player.y;
                let moved = false;
                
                if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) {
                    this.player.y -= this.player.speed;
                    this.player.direction = 'up';
                    moved = true;
                }
                if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) {
                    this.player.y += this.player.speed;
                    this.player.direction = 'down';
                    moved = true;
                }
                if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) {
                    this.player.x -= this.player.speed;
                    this.player.direction = 'left';
                    moved = true;
                }
                if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) {
                    this.player.x += this.player.speed;
                    this.player.direction = 'right';
                    moved = true;
                }
                
                if (this.checkCollision()) {
                    this.player.x = oldX;
                    this.player.y = oldY;
                    moved = false;
                }
                
                this.player.moving = moved;
                if (moved) {
                    this.player.animFrame += this.deltaTime * 0.01;
                }
            }
            
            checkCollision() {
                const corners = [
                    { x: this.player.x, y: this.player.y },
                    { x: this.player.x + this.player.width - 1, y: this.player.y },
                    { x: this.player.x, y: this.player.y + this.player.height - 1 },
                    { x: this.player.x + this.player.width - 1, y: this.player.y + this.player.height - 1 }
                ];
                
                for (let corner of corners) {
                    const tileX = Math.floor(corner.x / this.tileSize);
                    const tileY = Math.floor(corner.y / this.tileSize);
                    
                    if (tileX < 0 || tileX >= this.mapWidth || tileY < 0 || tileY >= this.mapHeight) {
                        return true;
                    }
                    
                    if (this.collisionMap[tileY] && this.collisionMap[tileY][tileX] === 1) {
                        return true;
                    }
                }
                
                return false;
            }
            
            updateMonsters() {
                this.monsters.forEach(monster => {
                    if (monster.defeated) return;
                    
                    monster.moveTimer += this.deltaTime;
                    if (monster.moveTimer > 3000) {
                        const directions = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}];
                        const dir = directions[Math.floor(Math.random() * 4)];
                        
                        const newX = monster.x + dir.x;
                        const newY = monster.y + dir.y;
                        
                        if (newX >= 0 && newX < this.mapWidth && newY >= 0 && newY < this.mapHeight) {
                            if (this.collisionMap[newY][newX] === 0) {
                                monster.x = newX;
                                monster.y = newY;
                            }
                        }
                        monster.moveTimer = 0;
                    }
                });
            }
            
            updateCamera() {
                this.camera.targetX = this.player.x - this.canvas.width / 2;
                this.camera.targetY = this.player.y - this.canvas.height / 2;
                
                this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.smoothing;
                this.camera.y += (this.camera.targetY - this.camera.y) * this.camera.smoothing;
                
                this.camera.x = Math.max(0, Math.min(this.camera.x, this.mapWidth * this.tileSize - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, this.mapHeight * this.tileSize - this.canvas.height));
            }
            
            checkInteractions() {
                const playerTileX = Math.floor(this.player.x / this.tileSize);
                const playerTileY = Math.floor(this.player.y / this.tileSize);
                
                // 몬스터와의 조우
                this.monsters.forEach(monster => {
                    if (monster.defeated) return;
                    
                    const distance = Math.sqrt(
                        Math.pow(monster.x - playerTileX, 2) + 
                        Math.pow(monster.y - playerTileY, 2)
                    );
                    
                    if (distance < 1.5) {
                        this.startBattle(monster);
                    }
                });
                
                // 체육관 관장과의 상호작용 (쿨다운 추가)
                if ((this.keys[' '] || this.keys['Space']) && !this.interactionCooldown) {
                    this.gymLeaders.forEach(leader => {
                        const distance = Math.sqrt(
                            Math.pow(leader.x - playerTileX, 2) + 
                            Math.pow(leader.y - playerTileY, 2)
                        );
                        
                        if (distance < 2) {
                            this.startGymBattle(leader);
                            this.interactionCooldown = 1000; // 1초 쿨다운
                        }
                    });
                }
                
                // 쿨다운 감소
                if (this.interactionCooldown > 0) {
                    this.interactionCooldown -= this.deltaTime;
                    if (this.interactionCooldown < 0) this.interactionCooldown = 0;
                }
            }
            
            startBattle(monster) {
                this.battleSystem.active = true;
                this.battleSystem.monster = monster;
                this.gameState = 'battle';
                
                const questions = this.gameData.quiz[monster.cert] || this.gameData.quiz.cp;
                this.battleSystem.currentQuestion = questions[Math.floor(Math.random() * questions.length)];
                
                console.log(`⚔️ ${monster.name}와의 퀴즈 배틀 시작!`);
            }
            
            startGymBattle(leader) {
                const dialogueText = leader.dialogue.join('\\n\\n');
                alert(dialogueText);
                
                const details = leader.certDetails;
                const detailMessage = `
🎓 ${details.fullName} (${details.code})

📋 시험 정보:
• 시험 시간: ${details.duration}
• 문항 수: ${details.questions}
• 합격 점수: ${details.passingScore}
• 시험 비용: ${details.cost}
• 유효 기간: ${details.validity}

📚 출제 영역:
${details.domains.map(domain => `• ${domain}`).join('\\n')}

배틀을 시작하시겠습니까?`;
                
                if (confirm(detailMessage)) {
                    const gymMonster = {
                        name: `${leader.name}의 AWS 챔피언`,
                        type: 'gym',
                        hp: 150,
                        maxHp: 150,
                        level: 5,
                        cert: leader.cert,
                        defeated: false
                    };
                    this.startBattle(gymMonster);
                }
            }
            
            handleBattleAnswer(selectedOption) {
                const question = this.battleSystem.currentQuestion;
                const correct = selectedOption === question.correct;
                
                if (correct) {
                    const damage = 25 + (question.difficulty * 10);
                    this.battleSystem.monster.hp -= damage;
                    
                    if (this.battleSystem.monster.hp <= 0) {
                        this.endBattle(true);
                    } else {
                        this.nextBattleRound();
                    }
                } else {
                    const damage = 15 + (question.difficulty * 5);
                    this.player.hp -= damage;
                    
                    if (this.player.hp <= 0) {
                        this.endBattle(false);
                    } else {
                        this.nextBattleRound();
                    }
                }
                
                alert(correct ? `정답! ${question.explanation}` : `오답! 정답: ${question.options[question.correct]}`);
            }
            
            nextBattleRound() {
                const questions = this.gameData.quiz[this.battleSystem.monster.cert] || this.gameData.quiz.cp;
                this.battleSystem.currentQuestion = questions[Math.floor(Math.random() * questions.length)];
            }
            
            endBattle(victory) {
                if (victory) {
                    const expGain = 50 + (this.battleSystem.monster.level * 10);
                    const creditsGain = 100 + (this.battleSystem.monster.level * 25);
                    
                    this.player.exp += expGain;
                    this.player.awsCredits += creditsGain;
                    
                    if (this.player.exp >= this.player.expToNext) {
                        this.player.level++;
                        this.player.exp -= this.player.expToNext;
                        this.player.expToNext += 50;
                        this.player.maxHp += 20;
                        this.player.hp = this.player.maxHp;
                    }
                    
                    this.battleSystem.monster.defeated = true;
                    console.log(`🎉 승리! EXP +${expGain}, AWS Credits +${creditsGain}`);
                } else {
                    this.player.hp = this.player.maxHp;
                    console.log('💔 패배... 체력을 회복하고 다시 도전하세요!');
                }
                
                this.battleSystem.active = false;
                this.gameState = 'overworld';
            }
            
            updateBattle() {
                // 배틀 업데이트 로직
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.gameState === 'overworld') {
                    this.renderOverworld();
                } else if (this.gameState === 'battle') {
                    this.renderBattle();
                }
                
                this.renderUI();
            }
            
            renderOverworld() {
                // 하늘 그라데이션
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#98FB98');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.renderMap();
                this.renderEntities();
            }
            
            renderMap() {
                const camera = this.camera;
                const tileSize = this.tileSize;
                
                const startX = Math.max(0, Math.floor(camera.x / tileSize));
                const endX = Math.min(this.mapWidth, Math.ceil((camera.x + this.canvas.width) / tileSize));
                const startY = Math.max(0, Math.floor(camera.y / tileSize));
                const endY = Math.min(this.mapHeight, Math.ceil((camera.y + this.canvas.height) / tileSize));
                
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        const screenX = x * tileSize - camera.x;
                        const screenY = y * tileSize - camera.y;
                        this.renderTile(this.map[y][x], screenX, screenY, x, y);
                    }
                }
            }
            
            renderTile(tileType, x, y, mapX, mapY) {
                const size = this.tileSize;
                
                switch(tileType) {
                    case 1: // 잔디 - 개선된 픽셀 아트
                        // 베이스 잔디
                        this.ctx.fillStyle = '#4A7C59';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 잔디 패턴
                        const grassSeed = (mapX * 7 + mapY * 11) % 16;
                        this.ctx.fillStyle = '#5D8A6B';
                        if (grassSeed < 8) {
                            this.ctx.fillRect(x + (grassSeed % 4) * 4, y + Math.floor(grassSeed / 4) * 8, 2, 6);
                            this.ctx.fillRect(x + (grassSeed % 4) * 4 + 2, y + Math.floor(grassSeed / 4) * 8 + 2, 2, 4);
                        }
                        
                        // 작은 꽃들
                        if (grassSeed === 3) {
                            this.ctx.fillStyle = '#FFD700';
                            this.ctx.fillRect(x + 6, y + 4, 2, 2);
                            this.ctx.fillStyle = '#FF69B4';
                            this.ctx.fillRect(x + 10, y + 8, 2, 2);
                        }
                        break;
                        
                    case 2: // 물 - 애니메이션 효과
                        const waterPhase = Math.sin(this.time * 0.003 + mapX * 0.2) * 0.3 + 0.7;
                        this.ctx.fillStyle = `hsl(210, 80%, ${25 + waterPhase * 15}%)`;
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 물결 효과
                        this.ctx.fillStyle = `hsl(200, 70%, ${35 + waterPhase * 10}%)`;
                        const waveY = y + 4 + Math.sin(this.time * 0.005 + mapX * 0.3) * 2;
                        this.ctx.fillRect(x, waveY, size, 4);
                        
                        // 반짝임
                        if ((mapX + mapY + Math.floor(this.time * 0.01)) % 20 === 0) {
                            this.ctx.fillStyle = '#FFFFFF';
                            this.ctx.fillRect(x + 6, y + 6, 2, 2);
                        }
                        break;
                        
                    case 3: // 나무 - 픽셀 아트 스타일 개선
                        // 잔디 배경
                        this.ctx.fillStyle = '#4A7C59';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 나무 줄기 (더 디테일하게)
                        this.ctx.fillStyle = '#8B4513';
                        this.ctx.fillRect(x + 6, y + 10, 4, 6);
                        this.ctx.fillStyle = '#A0522D';
                        this.ctx.fillRect(x + 7, y + 11, 2, 4);
                        
                        // 나뭇잎 (레이어드 스타일)
                        this.ctx.fillStyle = '#228B22';
                        this.ctx.fillRect(x + 2, y + 2, 12, 12);
                        this.ctx.fillStyle = '#32CD32';
                        this.ctx.fillRect(x + 3, y + 3, 10, 10);
                        this.ctx.fillStyle = '#90EE90';
                        this.ctx.fillRect(x + 5, y + 5, 6, 6);
                        
                        // 나뭇잎 하이라이트
                        this.ctx.fillStyle = '#98FB98';
                        this.ctx.fillRect(x + 6, y + 6, 4, 4);
                        
                        // 과일 (랜덤)
                        const treeSeed = (mapX * 13 + mapY * 17) % 20;
                        if (treeSeed < 3) {
                            this.ctx.fillStyle = '#FF6347';
                            this.ctx.fillRect(x + 4 + treeSeed * 2, y + 7 + treeSeed, 2, 2);
                        }
                        break;
                    case 7: // 길 - 돌길 스타일
                        this.ctx.fillStyle = '#D2B48C';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 돌 패턴
                        this.ctx.fillStyle = '#C0A080';
                        this.ctx.fillRect(x + 2, y + 2, 4, 4);
                        this.ctx.fillRect(x + 8, y + 6, 4, 4);
                        this.ctx.fillRect(x + 4, y + 10, 6, 4);
                        
                        // 작은 자갈
                        this.ctx.fillStyle = '#A0826D';
                        const roadSeed = (mapX * 5 + mapY * 7) % 8;
                        this.ctx.fillRect(x + roadSeed, y + (roadSeed * 2) % size, 2, 2);
                        break;
                        
                    case 8: // AWS 센터 - 현대적 건물
                        this.ctx.fillStyle = '#FF9900';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 건물 디테일
                        this.ctx.fillStyle = '#FFB84D';
                        this.ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
                        
                        // 창문
                        this.ctx.fillStyle = '#87CEEB';
                        this.ctx.fillRect(x + 4, y + 4, 3, 3);
                        this.ctx.fillRect(x + 9, y + 4, 3, 3);
                        this.ctx.fillRect(x + 4, y + 9, 3, 3);
                        this.ctx.fillRect(x + 9, y + 9, 3, 3);
                        
                        // AWS 로고
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.fillRect(x + 6, y + 6, 4, 2);
                        break;
                        
                    case 11: // CP 체육관 - 초록색 건물
                        this.ctx.fillStyle = '#2E7D32';
                        this.ctx.fillRect(x, y, size, size);
                        
                        this.ctx.fillStyle = '#4CAF50';
                        this.ctx.fillRect(x + 2, y + 2, size - 4, size - 4);
                        
                        // CP 마크
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.fillRect(x + 6, y + 6, 4, 4);
                        this.ctx.fillStyle = '#2E7D32';
                        this.ctx.fillRect(x + 7, y + 7, 2, 2);
                        break;
                        
                    case 15: // 숲 - 짙은 녹색
                        this.ctx.fillStyle = '#1B5E20';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 숲 텍스처
                        const forestSeed = (mapX * 11 + mapY * 13) % 12;
                        this.ctx.fillStyle = '#2E7D32';
                        if (forestSeed < 6) {
                            this.ctx.fillRect(x + (forestSeed % 3) * 5, y + Math.floor(forestSeed / 3) * 8, 3, 5);
                        }
                        break;
                        
                    case 16: // 산 - 바위 텍스처
                        this.ctx.fillStyle = '#5D4037';
                        this.ctx.fillRect(x, y, size, size);
                        
                        // 바위 패턴
                        this.ctx.fillStyle = '#6D4C41';
                        this.ctx.fillRect(x + 2, y + 2, 6, 6);
                        this.ctx.fillRect(x + 8, y + 8, 6, 6);
                        
                        this.ctx.fillStyle = '#8D6E63';
                        this.ctx.fillRect(x + 4, y + 4, 3, 3);
                        this.ctx.fillRect(x + 10, y + 10, 3, 3);
                        break;
                    default:
                        this.ctx.fillStyle = '#90EE90';
                        this.ctx.fillRect(x, y, size, size);
                        break;
                }
            }
            
            renderEntities() {
                // 몬스터 렌더링
                this.monsters.forEach(monster => {
                    if (monster.defeated) return;
                    
                    const screenX = monster.x * this.tileSize - this.camera.x;
                    const screenY = monster.y * this.tileSize - this.camera.y;
                    
                    this.renderMonster(monster, screenX, screenY);
                });
                
                // 체육관 관장 렌더링
                this.gymLeaders.forEach(leader => {
                    if (leader.defeated) return;
                    
                    const screenX = leader.x * this.tileSize - this.camera.x;
                    const screenY = leader.y * this.tileSize - this.camera.y;
                    
                    this.renderGymLeader(leader, screenX, screenY);
                });
                
                // 플레이어 렌더링
                const screenX = this.player.x - this.camera.x;
                const screenY = this.player.y - this.camera.y;
                this.renderPlayer(screenX, screenY);
            }
            
            renderPlayer(x, y) {
                // 그림자
                this.ctx.fillStyle = 'rgba(0,0,0,0.4)';
                this.ctx.beginPath();
                this.ctx.ellipse(x + 8, y + 14, 6, 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 다리
                this.ctx.fillStyle = '#1565C0';
                this.ctx.fillRect(x + 5, y + 12, 2, 4);
                this.ctx.fillRect(x + 9, y + 12, 2, 4);
                
                // 몸통 (AWS 티셔츠)
                this.ctx.fillStyle = '#FF9900';
                this.ctx.fillRect(x + 4, y + 8, 8, 6);
                
                // 셔츠 디테일
                this.ctx.fillStyle = '#FFB84D';
                this.ctx.fillRect(x + 4, y + 8, 2, 6);
                
                // 팔
                this.ctx.fillStyle = '#FFDBAC';
                this.ctx.fillRect(x + 2, y + 9, 2, 4);
                this.ctx.fillRect(x + 12, y + 9, 2, 4);
                
                // 머리
                this.ctx.fillStyle = '#FFDBAC';
                this.ctx.fillRect(x + 5, y + 3, 6, 6);
                
                // 머리카락
                this.ctx.fillStyle = '#2C1810';
                this.ctx.fillRect(x + 4, y + 2, 8, 4);
                
                // 눈
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(x + 6, y + 5, 1, 1);
                this.ctx.fillRect(x + 9, y + 5, 1, 1);
                
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(x + 6, y + 5, 1, 1);
                this.ctx.fillRect(x + 9, y + 5, 1, 1);
                
                // 입
                this.ctx.fillStyle = '#D4A574';
                this.ctx.fillRect(x + 7, y + 7, 2, 1);
                
                // AWS 로고
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 4px monospace';
                this.ctx.fillText('AWS', x + 5, y + 12);
                
                // 신발
                this.ctx.fillStyle = '#1A1A1A';
                this.ctx.fillRect(x + 4, y + 15, 3, 2);
                this.ctx.fillRect(x + 9, y + 15, 3, 2);
            }
            
            renderMonster(monster, x, y) {
                const bounce = Math.sin(this.time * 0.005) * 1;
                
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(x + 8, y + 14, 6, 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#FF9900';
                this.ctx.fillRect(x + 2, y + 4 + bounce, 12, 10);
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(x + 4, y + 6 + bounce, 2, 2);
                this.ctx.fillRect(x + 10, y + 6 + bounce, 2, 2);
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '8px monospace';
                this.ctx.fillText(monster.name.substring(0, 6), x - 5, y - 2);
            }
            
            renderGymLeader(leader, x, y) {
                this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                this.ctx.beginPath();
                this.ctx.ellipse(x + 8, y + 14, 6, 2, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                const colors = { cp: '#2E7D32', saa: '#1565C0', dva: '#E65100', sap: '#4A148C' };
                
                this.ctx.fillStyle = colors[leader.cert] || '#424242';
                this.ctx.fillRect(x + 4, y + 8, 8, 6);
                
                this.ctx.fillStyle = '#FFDBAC';
                this.ctx.fillRect(x + 5, y + 3, 6, 6);
                
                this.ctx.fillStyle = '#2C1810';
                this.ctx.fillRect(x + 4, y + 2, 8, 4);
                
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(x + 6, y + 5, 1, 1);
                this.ctx.fillRect(x + 9, y + 5, 1, 1);
                
                this.ctx.fillStyle = '#1565C0';
                this.ctx.fillRect(x + 6, y + 12, 4, 4);
                
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = 'bold 8px monospace';
                this.ctx.fillText(leader.cert.toUpperCase(), x + 2, y - 2);
            }
            
            renderBattle() {
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#1A237E');
                gradient.addColorStop(1, '#3F51B5');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.battleSystem.monster) {
                    this.renderBattleMonster(this.canvas.width * 0.75 - 16, this.canvas.height * 0.25 - 16);
                    this.renderMonsterHP(this.canvas.width * 0.75, this.canvas.height * 0.25 - 50);
                }
                
                this.renderPlayer(this.canvas.width * 0.25 - 16, this.canvas.height * 0.65 - 16);
                
                if (this.battleSystem.currentQuestion) {
                    this.renderQuizInterface();
                }
            }
            
            renderBattleMonster(x, y) {
                this.ctx.fillStyle = '#FF9900';
                this.ctx.fillRect(x + 2, y + 4, 12, 10);
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.fillRect(x + 4, y + 6, 2, 2);
                this.ctx.fillRect(x + 10, y + 6, 2, 2);
            }
            
            renderMonsterHP(x, y) {
                const hpBarWidth = 180;
                const hpBarHeight = 16;
                const hpBarX = x - hpBarWidth / 2;
                
                this.ctx.fillStyle = '#424242';
                this.ctx.fillRect(hpBarX - 2, y - 2, hpBarWidth + 4, hpBarHeight + 4);
                
                this.ctx.fillStyle = '#F44336';
                this.ctx.fillRect(hpBarX, y, hpBarWidth, hpBarHeight);
                
                const hpPercent = this.battleSystem.monster.hp / this.battleSystem.monster.maxHp;
                this.ctx.fillStyle = '#4CAF50';
                this.ctx.fillRect(hpBarX, y, hpBarWidth * hpPercent, hpBarHeight);
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText(this.battleSystem.monster.name, hpBarX, y - 8);
            }
            
            renderQuizInterface() {
                const question = this.battleSystem.currentQuestion;
                
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(50, this.canvas.height - 220, this.canvas.width - 100, 170);
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = '16px monospace';
                this.ctx.fillText(question.question, 70, this.canvas.height - 190);
                
                question.options.forEach((option, index) => {
                    const optionY = this.canvas.height - 160 + index * 35;
                    const optionX = 70;
                    
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.fillRect(optionX - 10, optionY - 15, this.canvas.width - 140, 30);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = '14px monospace';
                    this.ctx.fillText(`${index + 1}. ${option}`, optionX, optionY);
                });
                
                this.ctx.fillStyle = '#FFD700';
                this.ctx.font = '12px monospace';
                this.ctx.fillText('1-4 키를 눌러 답을 선택하세요', 70, this.canvas.height - 70);
            }
            
            renderUI() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, 50);
                
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText(`Lv.${this.player.level}`, 10, 20);
                
                const hpBarWidth = 100;
                const hpPercent = this.player.hp / this.player.maxHp;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(50, 10, hpBarWidth, 12);
                this.ctx.fillStyle = hpPercent > 0.3 ? '#4CAF50' : '#F44336';
                this.ctx.fillRect(50, 10, hpBarWidth * hpPercent, 12);
                this.ctx.fillStyle = '#FFF';
                this.ctx.font = '10px monospace';
                this.ctx.fillText(`${this.player.hp}/${this.player.maxHp}`, 55, 20);
                
                this.ctx.fillStyle = '#FF9900';
                this.ctx.font = 'bold 12px monospace';
                this.ctx.fillText(`💰 ${this.player.awsCredits}`, 200, 20);
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 게임 시작
        console.log('게임 시작!');
        new Game();
    </script>
</body>
</html>